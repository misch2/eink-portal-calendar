#!/usr/bin/env perl

use strict;

use FindBin qw($Bin);
use lib "$Bin/lib";

use Mojolicious::Lite;
use DDP;
use DateTime;
use DateTime::Format::Strptime;
use Imager;
use Text::Unidecode;
use Readonly;
use List::Util;
use Try::Tiny;
use Digest::SHA1 qw(sha1_hex);
use Time::HiRes;

use PortalCalendar::Integration::iCal;
use PortalCalendar::Minion;

Readonly my $WIDTH        => 480;
Readonly my $HEIGHT       => 800;
Readonly my @PORTAL_ICONS => qw(a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 b11 b14 c3 c7 d5 e4);

# Static files are automatically served from the /public subfolder.

get '/ping' => sub {
    my $self = shift;
    return $self->render(json => { status => 'ok' });
};

# side by side comparison
get '/' => sub {
    my $self = shift;
    return $self->render(template => 'test', format => 'html');
};

get '/config' => sub {
    my $self   = shift;
    my $config = {
        #
        sleep => 3600,

        #display     => "BW",                            # "bw", "grayscale",
        # bitmap_path => "/calendar/bitmap/epapermono",
    };
    $self->render(json => $config);
};

# main HTML page with calendar (either for current or for specific date)
get '/calendar/html' => sub {
    my $self = shift;
    return html_calendar($self, DateTime->now());
};

get '/calendar/html/:date' => sub {
    my $self = shift;
    my $dt   = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d')->parse_datetime($self->stash('date'));
    return html_calendar($self, $dt);
};

# shortcuts so that we can finetune the parameters here and not constantly reupload them into ESP
get '/calendar/bitmap/epapermono' => sub {
    my $self = shift;
    return generate_bitmap(
        $self,
        {
            rotate    => 3,
            numcolors => 2,
            gamma     => 1.8,
            format    => 'raw1bpp',
        }
    );
};

get '/calendar/bitmap/epapergray' => sub {
    my $self = shift;
    return generate_bitmap(
        $self,
        {
            rotate    => 3,
            numcolors => 256,
            gamma     => 1.8,
            format    => 'raw8bpp',
        }
    );
};

# /calendar/bitmap
# /calendar/bitmap?rotate=1&format=png
# /calendar/bitmap?rotate=2&flip=x
# /calendar/bitmap?rotate=3&flip=xy&format=raw8bpp
get '/calendar/bitmap' => sub {
    my $self = shift;

    my $rotate = $self->req->param('rotate') // 0;
    my $flip   = $self->req->param('flip')   // '';
    my $colors = $self->req->param('colors') // 256;
    my $gamma  = $self->req->param('gamma')  // 1.0;
    my $format = $self->req->param('format') // 'png';

    return generate_bitmap(
        $self,
        {
            rotate    => $rotate,
            flip      => $flip,
            numcolors => $colors,
            gamma     => $gamma,
            format    => $format,
        }
    );
};

# # redirect warnings
$SIG{__WARN__} = sub {
    my $message = shift;
    $message =~ s/\n$//;
    @_ = (app->log, $message);
    goto &Mojo::Log::warn;
};

app->log->path("$Bin/log/$ENV{MOJO_MODE}.log");
app->renderer->cache->max_keys(0) if $ENV{MOJO_MODE} eq 'development';    # do not cache CSS etc. in devel mode

# # logging to STDERR (for morbo command line usage):
app->log->handle(\*STDERR);
app->secrets([ $ENV{MOJO_SECRET_PASSPHRASE} ]);

plugin 'TagHelpers';
plugin 'RenderFile';
plugin 'Minion' => {
    SQLite => 'sqlite:' . "$Bin/local/minion.db",    # app->home->child('minion.db'),
};
plugin 'Minion::Admin' => {                          # Host Admin UI
    route => app->routes->any('/admin'),
};

# define the minion tasks
app->minion->add_task(
    #
    regenerate_image => sub {
        PortalCalendar::Minion::regenerate_image(@_);
    }
);

plugin 'Cron' => {
    '0 * * * *' => sub {    # every hour
        app->log->info("enqueuing regenerate_image task");
        app->minion->enqueue('regenerate_image', []);
    }
};

app->start;

########################################################################

sub html_calendar {
    my $self = shift;
    my $dt   = shift;

    # keep the calendar random, but consistent for any given day
    srand($dt->ymd(''));

    $dt->set_locale($ENV{DATETIME_LOCALE} || 'en-US');

    my @today_events;
    if ($ENV{CALENDAR_ICS_URL}) {
        my $calendar = PortalCalendar::Integration::iCal->new(ics_url => $ENV{CALENDAR_ICS_URL}, cache_dir => "$Bin/cache/lwp");
        try {
            @today_events = $calendar->get_today_events($dt);

            #p @today_events;
        } catch {
            warn "Error: $_";
        };
    }

    my $gray_probability = 0.25;
    my @icons;
    foreach my $name (List::Util::shuffle @PORTAL_ICONS) {
        push @icons,
            {
            name   => $name,
            grayed => (rand() < $gray_probability ? 1 : 0)
            };
    }
    while (scalar @icons < 16) {    # produce enough icons even with small number of source images
        push @icons, @icons;
    }

    return $self->render(
        template => 'calendar',
        format   => 'html',

        # other variables
        date                 => $dt,
        icons                => \@icons,
        calendar_events      => \@today_events,
        has_calendar_entries => (scalar @today_events ? 1 : 0),
    );
}

sub generate_bitmap {
    my $self = shift;
    my $args = shift;

    # This source image needs to be generated by 'server/scripts/generate_img_from_web' set up to run periodically from a cron job.
    my $img = Imager->new(file => "$Bin/generated_images/current_calendar.png") or die Imager->errstr;

    # If the generated image is larger (probably due to invalid CSS), crop it so that it display at least something:
    if ($img->getheight > $HEIGHT) {
        my $tmp = $img->crop(left => 0, top => 0, width => $WIDTH, height => $HEIGHT);
        die $img->errstr unless $tmp;
        $img = $tmp;
    }

    if ($args->{rotate} && $args->{rotate} != 0) {
        my $tmp;
        if ($args->{rotate} == 1) {
            $tmp = $img->rotate(right => 90);
        } elsif ($args->{rotate} == 2) {
            $tmp = $img->rotate(right => 180);
        } elsif ($args->{rotate} == 3) {
            $tmp = $img->rotate(right => 270);
        } else {
            die "unknown 'rotate' value: $args->{rotate}";
        }
        die $img->errstr unless $tmp;
        $img = $tmp;
    }

    if ($args->{flip} && $args->{flip} ne '') {
        my $tmp;
        if ($args->{flip} eq 'x') {
            $tmp = $img->flip(dir => 'h');
        } elsif ($args->{flip} eq 'y') {
            $tmp = $img->flip(dir => 'v');
        } elsif ($args->{flip} eq 'xy') {
            $tmp = $img->flip(dir => 'vh');
        } else {
            die "unknown 'flip' value: $args->{flip}";
        }
        die $img->errstr unless $tmp;
        $img = $tmp;
    }

    if ($args->{gamma} && $args->{gamma} != 1) {
        my @map = map { int(0.5 + 255 * ($_ / 255)**$args->{gamma}) } 0 .. 255;    # inplace conversion, no need to use $tmp here
        $img->map(all => \@map);
    }

    if ($args->{numcolors} && $args->{numcolors} < 256) {
        my $tmp = $img->to_paletted(
            {
                make_colors => {
                    2   => 'mono',
                    4   => 'gray4',
                    16  => 'gray16',
                    256 => 'gray',
                }->{ $args->{numcolors} },
                translate => 'closest',    # closest, errdiff

                # errdiff     => 'jarvis',      # floyd, jarvis, stucki, ...
            }
        );
        die $img->errstr unless $tmp;
        $img = $tmp;
    }

    if ($args->{format} eq 'png') {
        my $out;
        $img->write(data => \$out, type => 'png') or die;
        return $self->render(data => $out, format => 'png');
    } elsif ($args->{format} =~ /^raw/) {
        my $bitmap = '';
        if ($args->{format} eq 'raw8bpp') {
            foreach my $y (0 .. $img->getheight - 1) {
                foreach my $gray ($img->getsamples(y => $y, format => '8bit', channels => [0])) {
                    $bitmap .= chr($gray);
                }
            }
        } elsif ($args->{format} eq 'raw1bpp') {
            foreach my $y (0 .. $img->getheight - 1) {
                my $byte   = 0;
                my $bitcnt = 0;
                foreach my $gray ($img->getsamples(y => $y, format => '8bit', channels => [0])) {
                    my $bit = $gray ? 1 : 0;
                    $byte = $byte << 1 | $bit;
                    $bitcnt++;
                    if ($bitcnt == 8) {
                        $bitmap .= chr($byte);
                        $byte   = 0;
                        $bitcnt = 0;
                    }
                }
            }
        } else {
            die "Unknown format requested: " . $args->{format};
        }

        # output format:
        #    "MM"
        #   checksum
        #    <sequence of raw values directly usable for uploading into eink display>
        my $out = "MM\n";
        $out .= sha1_hex($bitmap) . "\n";
        $out .= $bitmap;

        return $self->render(data => $out);
    } else {
        die "Unknown format requested: " . $args->{format};
    }
}