#!/usr/bin/env perl

use strict;

use FindBin qw($Bin);
use lib "$Bin/mock";
use lib "$Bin/lib";

use Mojolicious::Lite;
use Mojo::SQLite;
use DateTime;
use DateTime::Format::Strptime;
use DateTime::Format::ISO8601;
use DDP;
use Time::HiRes;

# FIXME for oauth:
use Mojo::Util qw(url_escape);
use Mojo::JSON qw(decode_json encode_json);

use PortalCalendar;
use PortalCalendar::Config;
use PortalCalendar::Minion;
use PortalCalendar::Schema;
use PortalCalendar::Integration::Google;

get '/ping' => sub {
    my $self = shift;
    return $self->render(json => { status => 'ok' });
};

get '/' => sub {
    my $self = shift;

    my $last_contact_ago;
    my $last_visit_dt;
    if (my $last_visit_raw = $self->get_config('_last_visit')) {
        $last_visit_dt = DateTime::Format::ISO8601->parse_datetime($last_visit_raw);

        $last_contact_ago = DateTime->now()->subtract_datetime($last_visit_dt);
    }
    return $self->render(
        template => 'index',
        format   => 'html',
        nav_link => 'index',

        last_contact_ago => $last_contact_ago,
        last_visit_dt    => $last_visit_dt,
        last_voltage     => ($self->get_config('_last_voltage')     // '(unknown)'),
        last_voltage_raw => ($self->get_config('_last_voltage_raw') // '(unknown)'),
    );
};

# side by side comparison
get '/test' => sub {
    my $self = shift;
    return $self->render(
        template => 'test',
        format   => 'html',
        nav_link => 'compare',
    );
};

get '/config_ui' => sub {
    my $self = shift;

    my $values = {};
    foreach my $name (@{ $self->config_obj->parameters }) {
        my $value = $self->get_config($name);
        $values->{$name} = $value;
    }

    return $self->render(
        template => 'config_ui',
        format   => 'html',
        values   => $values,
        nav_link => 'config_ui',
    );
};

post '/config_ui' => sub {
    my $self = shift;

    foreach my $name (@{ $self->config_obj->parameters }) {
        my $value = $self->req->param($name);
        $self->set_config($name, $value);
    }

    $self->flash(message => "Parameters saved.");

    PortalCalendar->new(app => $self)->update_mqtt('min_voltage',           $self->get_config('min_voltage'));
    PortalCalendar->new(app => $self)->update_mqtt('max_voltage',           $self->get_config('max_voltage'));
    PortalCalendar->new(app => $self)->update_mqtt('alert_voltage',         $self->get_config('alert_voltage'));
    PortalCalendar->new(app => $self)->update_mqtt('voltage_divider_ratio', $self->get_config('voltage_divider_ratio'));
    PortalCalendar->new(app => $self)->update_mqtt('sleep_time',            $self->get_config('sleep_time'));

    $self->enqueue_task_only_once('parse_calendars');
    $self->enqueue_task_only_once('parse_weather');
    $self->enqueue_task_only_once('parse_googlefit');
    $self->enqueue_task_only_once('generate_image');

    $self->redirect_to('/config_ui');
};

# main HTML page with calendar (either for current or for specific date)
get '/calendar/html' => sub {
    my $self = shift;
    return PortalCalendar->new(app => $self)->html_for_date(DateTime->now());
};

get '/calendar/html/:date' => sub {
    my $self = shift;
    my $dt   = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d')->parse_datetime($self->stash('date'));
    return PortalCalendar->new(app => $self)->html_for_date($dt);
};

# /calendar/bitmap
# /calendar/bitmap?rotate=1&format=png
# /calendar/bitmap?rotate=2&flip=x
# /calendar/bitmap?rotate=3&flip=xy&format=raw8bpp
get '/calendar/bitmap' => sub {
    my $self = shift;

    my $rotate = $self->req->param('rotate') // 0;
    my $flip   = $self->req->param('flip')   // '';
    my $colors = $self->req->param('colors') // 256;
    my $gamma  = $self->req->param('gamma')  // 1.0;
    my $format = $self->req->param('format') // 'png';

    return PortalCalendar->new(app => $self)->generate_bitmap(
        {
            rotate    => $rotate,
            flip      => $flip,
            numcolors => $colors,
            gamma     => $gamma,
            format    => $format,
        }
    );
};

# Return configuration data to client (ePaper display):
get '/config' => sub {
    my $self = shift;

    $self->set_config('_last_visit',       DateTime->now()->iso8601);
    $self->set_config('_last_voltage',     $self->req->param('voltage')     // '');    # value has NOT NULL restriction
    $self->set_config('_last_voltage_raw', $self->req->param('voltage_raw') // '');    # value has NOT NULL restriction

    PortalCalendar->new(app => $self)->update_mqtt('voltage',         $self->req->param('voltage') + 0.001);          # to force grafana to store changed values
    PortalCalendar->new(app => $self)->update_mqtt('voltage_raw',     $self->req->param('voltage_raw') + 0.001);      # to force grafana to store changed values
    PortalCalendar->new(app => $self)->update_mqtt('battery_percent', $self->calculate_battery_percent() + 0.001);    # to force grafana to store changed values
    PortalCalendar->new(app => $self)->update_mqtt('last_visit',      DateTime->now()->rfc3339);

    PortalCalendar->new(app => $self)->update_mqtt('voltage',         $self->req->param('voltage'));
    PortalCalendar->new(app => $self)->update_mqtt('voltage_raw',     $self->req->param('voltage_raw'));
    PortalCalendar->new(app => $self)->update_mqtt('battery_percent', $self->calculate_battery_percent());

    my $ret = {

        # {// undef} to force scalars
        sleep                 => $self->get_config('sleep_time')            // undef,
        critical_voltage      => $self->get_config('alert_voltage')         // undef,
        voltage_divider_ratio => $self->get_config('voltage_divider_ratio') // undef,
        battery_percent       => $self->calculate_battery_percent()         // undef,
        ota_mode              => ($self->get_config('ota_mode') ? \1 : \0),    # JSON true/false

        #display     => "BW",                            # "bw", "grayscale",
        # bitmap_path => "/calendar/bitmap/epapermono",
    };

    $self->render(json => $ret);
};

# shortcuts so that we can finetune the parameters here and not constantly reupload them into ESP
get '/calendar/bitmap/epapermono' => sub {
    my $self = shift;

    $self->set_config('_last_visit', DateTime->now()->iso8601);
    return PortalCalendar->new(app => $self)->generate_bitmap(
        {
            rotate    => 3,
            numcolors => 2,
            gamma     => 1.8,
            format    => 'raw1bpp',
        }
    );
};

get '/calendar/bitmap/epapergray' => sub {
    my $self = shift;

    $self->set_config('_last_visit', DateTime->now()->iso8601);
    return PortalCalendar->new(app => $self)->generate_bitmap(
        {
            rotate    => 3,
            numcolors => 4,
            gamma     => 1.8,
            format    => 'raw2bpp',
        }
    );
};

get '/auth/googlefit' => sub {
    my $self = shift;

    # see https://developers.google.com/identity/protocols/oauth2/web-server#httprest_1
    my $goauth = PortalCalendar::Integration::Google->new;
    my $url    = $goauth->google_oauth2_auth_url .
        #
        "?client_id=" . $self->get_config('googlefit_client_id') .
        #
        "&access_type=offline&response_type=code&scope=" . $goauth->googlefit_oauth2_scope .
        #
        "&include_granted_scopes=true&redirect_uri=" . url_escape($self->get_config('googlefit_auth_callback'));

    $self->log->info("Redirecting to [$url]");
    $self->redirect_to($url);
};

# OAuth 2 callback from google
get '/auth/googlefit/cb' => sub {
    my ($self) = @_;

    $self->log->info("in callback, received this:");
    $self->log->info("code: " . $self->req->param('code'));
    $self->log->info("scope: " . $self->req->param('scope'));

    $self->log->info("converting code to a token");

    #Get tokens from auth code
    my $goauth = PortalCalendar::Integration::Google->new;
    my $res    = $self->app->ua->post(
        $goauth->google_oauth2_token_url,
        'form',
        {
            code          => $self->req->param('code'),
            client_id     => $self->get_config('googlefit_client_id'),
            client_secret => $self->get_config('googlefit_client_secret'),
            redirect_uri  => $self->get_config('googlefit_auth_callback'),
            grant_type    => 'authorization_code',

            #scope         => googlefit_oauth2_scope,
        }
    )->res;
    $self->log->info("response: " . $res->as_string);

    if (!$res->is_success) {
        return $self->render(
            template => 'auth_error',
            format   => 'html',
            nav_link => 'config_ui',

            # page-specific variables
            error => decode_json($res->body),
        );
    }

    # Save both tokens
    #$self->log->info(DDP::np($res->json));
    $self->log->info("JSON content: " . DDP::np($res->json));
    $self->set_config('_googlefit_refresh_token', $res->json->{refresh_token});
    $self->set_config('_googlefit_access_token',  $res->json->{access_token});

    # $self->set_config('_googlefit_token_json',    encode_json($res->json));

    $self->redirect_to('/auth/googlefit/success');
};

get '/auth/googlefit/success' => sub {
    my ($self) = @_;

    # Read access token from session
    my $a_token = $self->get_config('_googlefit_access_token') or die "No access token!";

    # my $token_json = decode_json($self->get_config('_googlefit_token_json'));
    return $self->render(
        template => 'auth_success',
        format   => 'html',
        nav_link => 'config_ui',

        # page-specific variables
        a_token    => $self->app->get_config('_googlefit_access_token'),
        r_token    => $self->app->get_config('_googlefit_refresh_token'),
        token_json => '?',                                                  # DDP::np($token_json),
    );
};

helper encode_json => sub {
    my $self = shift;
    my $data = shift;
    return Mojo::JSON::encode_json($data);
};

helper config_obj => sub {
    my $self = shift;
    state $obj = PortalCalendar::Config->new(app => $self);
};

helper get_config => sub {
    my $self = shift;
    my $name = shift;
    return $self->config_obj->get($name);
};

helper set_config => sub {
    my $self  = shift;
    my $name  = shift;
    my $value = shift;
    return $self->config_obj->set($name, $value);
};

helper calculate_battery_percent => sub {
    my $self = shift;
    my $min  = $self->get_config('min_voltage');
    my $max  = $self->get_config('max_voltage');
    my $cur  = $self->get_config('_last_voltage');
    return unless $min && $max && $cur;
    return 100 * ($cur - $min) / ($max - $min);
};

helper enqueue_task_only_once => sub {
    my $self = shift;
    my $name = shift;

    my $new_id;
    if (my $total = app->minion->jobs({ states => ['inactive'], tasks => [$name] })->total) {
        $self->log->warn("Task '$name' already enqueued, skipping it");
    } else {
        $self->log->info("Enqueuing task '$name'");
        $new_id = app->minion->enqueue($name, []);
    }
    return $new_id;
};

helper schema => sub { state $schema = PortalCalendar::Schema->connect("dbi:SQLite:local/calendar.db") };

plugin 'Config';    # loads config from app.<mode>.conf (production/development) or from app.conf as a fallback
plugin 'TagHelpers';
plugin 'RenderFile';
plugin 'Minion' => {
    SQLite => 'sqlite:' . "local/minion.db",    # app->home->child('minion.db'),

};
plugin 'Minion::Admin' => {                     # Host Admin UI
    route => app->routes->any('/admin'),
};

plugin 'Cron' => {

    # every hour
    '0 * * * *' => sub {
        my $id1 = app->minion->enqueue('parse_calendars', []);
        my $id2 = app->minion->enqueue('parse_weather',   []);
        my $id3 = app->minion->enqueue('parse_googlefit', []);
        app->minion->enqueue('generate_image', [], { parents => [ $id1, $id2, $id3 ] });
    },
};

setup_logger();
run_migrations();

# define minion tasks
app->minion->add_task(
    #
    generate_image => sub {
        PortalCalendar::Minion::regenerate_image(@_);
    }
);
app->minion->add_task(
    parse_calendars => sub {
        PortalCalendar::Minion::reload_calendars(@_);
    }
);
app->minion->add_task(
    parse_weather => sub {
        PortalCalendar::Minion::reload_weather(@_);
    }
);
app->minion->add_task(
    parse_googlefit => sub {
        PortalCalendar::Minion::reload_googlefit(@_);
    }
);

app->enqueue_task_only_once('generate_image');

app->renderer->cache->max_keys(0) if app->config->{disable_renderer_cache};    # do not cache CSS etc. in devel mode
app->secrets([ app->config->{mojo_passphrase} ]);

DateTime->DefaultLocale(app->config->{datetime_locale});

app->log->info("Application started");
app->start;

########################################################################

sub setup_logger {

    # redirect warnings
    $SIG{__WARN__} = sub {
        my $message = shift;
        $message =~ s/\n$//;
        @_ = (app->log, $message);
        goto &Mojo::Log::warn;
    };

    app->log->level(app->config->{logging}->{level});

    if (app->config->{logging}->{file} eq 'STDERR') {

        # logging to STDERR (for morbo command line usage):
        app->log->handle(\*STDERR);
    } else {
        app->log->path(app->config->{logging}->{file});
    }

    app->log->info("Starting app...");
    return;
}

sub run_migrations {
    my $db = Mojo::SQLite->new("sqlite:local/calendar.db");
    $db->auto_migrate(1)->migrations->from_data();

    # execute any SQL via this handle to run the migrations automatically:
    my $version = $db->db->query('select sqlite_version() as version');
    return;
}

__DATA__
@@ migrations
-- 1 up
CREATE TABLE config (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name VARCHAR NOT NULL UNIQUE,
    value VARCHAR NOT NULL
);

-- 2 up
-- INSERT INTO config (name, value) VALUES ('broken_glass', '0');

-- 3 up
-- INSERT INTO config (name, value) VALUES ('sleep_time', '3600');

-- 4 up
-- INSERT INTO config (name, value) VALUES ('web_calendar1', '0');
-- INSERT INTO config (name, value) VALUES ('web_calendar_ics_url1', '');
-- INSERT INTO config (name, value) VALUES ('web_calendar2', '0');
-- INSERT INTO config (name, value) VALUES ('web_calendar_ics_url2', '');
-- INSERT INTO config (name, value) VALUES ('web_calendar3', '0');
-- INSERT INTO config (name, value) VALUES ('web_calendar_ics_url3', '');
-- INSERT INTO config (name, value) VALUES ('max_icons_for_calendar', '5');
--
-- INSERT INTO config (name, value) VALUES ('totally_random_icon', '0');
-- INSERT INTO config (name, value) VALUES ('min_random_icons', '4');
-- INSERT INTO config (name, value) VALUES ('max_random_icons', '10');
-- INSERT INTO config (name, value) VALUES ('max_icons_with_calendar', '5');

-- 5 up
CREATE TABLE calendar_events_raw (
    calendar_id INTEGER NOT NULL PRIMARY KEY,
    events_raw BLOB
);

-- 6 up
ALTER TABLE calendar_events_raw RENAME TO cache;
ALTER TABLE cache RENAME COLUMN calendar_id TO id;
ALTER TABLE cache RENAME COLUMN events_raw TO data;

-- 7 up
DROP TABLE cache;
CREATE TABLE cache (
    id VARCHAR(255) NOT NULL PRIMARY KEY,
    data BLOB
);
