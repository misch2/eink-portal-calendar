#!/usr/bin/env perl

use strict;

use FindBin qw($Bin);
use lib "$Bin/lib";

use Mojolicious::Lite;
use DDP;
use DateTime;
use DateTime::Format::Strptime;
use Imager;
use Text::Unidecode;
use Readonly;
use List::Util;
use Try::Tiny;
use Digest::SHA1 qw(sha1_hex);

use PortalCalendar::Integration::iCal;

Readonly my $WIDTH        => 480;
Readonly my $HEIGHT       => 800;
Readonly my @PORTAL_ICONS => qw(a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 b11 b14 c3 c7 d5 e4);

# Static files are automatically served from the /public subfolder.

get '/ping' => sub {
    my $self   = shift;
    return $self->render(json => { status => 'ok' });
};

# side by side comparison
get '/' => sub {
    my $self = shift;
    return $self->render(template => 'test', format => 'html');
};

# main HTML page with calendar (either for current or for specific date)
get '/calendar/html' => sub {
    my $self = shift;
    return html_calendar($self, DateTime->now());
};

get '/calendar/html/:date' => sub {
    my $self = shift;
    my $dt   = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d')->parse_datetime($self->stash('date'));
    return html_calendar($self, $dt);
};

# shortcuts so that we can finetune the parameters here and not constantly reupload them into ESP
get '/calendar/bitmap/epapermono' => sub {
    my $self = shift;
    return generate_bitmap($self, 3, '', 170, 'raw1bpp');
};

get '/calendar/bitmap/epapergray' => sub {
    my $self = shift;
    return generate_bitmap($self, 3, '', undef, 'raw8bpp');
};

# /calendar/bitmap
# /calendar/bitmap?rotate=1&format=png
# /calendar/bitmap?rotate=2&flip=x
# /calendar/bitmap?rotate=3&flip=xy&format=raw8bpp
get '/calendar/bitmap' => sub {
    my $self = shift;

    my $rotate    = $self->req->param('rotate')    // 0;
    my $flip      = $self->req->param('flip')      // '';
    my $threshold = $self->req->param('threshold') // undef;
    my $format    = $self->req->param('format')    // 'png';

    return generate_bitmap($self, $rotate, $flip, $threshold, $format);
};

plugin 'TagHelpers';
plugin 'RenderFile';

# # redirect warnings
$SIG{__WARN__} = sub {
    my $message = shift;
    $message =~ s/\n$//;
    @_ = (app->log, $message);
    goto &Mojo::Log::warn;
};

# # logging to STDERR (for morbo command line usage):
# app->log->handle(\*STDERR);
app->log->path("$Bin/log/$ENV{MOJO_MODE}.log");

app->secrets([ $ENV{MOJO_SECRET_PASSPHRASE} ]);
app->start;

########################################################################

sub html_calendar {
    my $self = shift;
    my $dt   = shift;

    # keep the calendar random, but consistent for any given day
    srand($dt->ymd(''));

    $dt->set_locale($ENV{DATETIME_LOCALE} || 'en-US');

    my @today_events;
    if ($ENV{CALENDAR_ICS_URL}) {
        my $calendar = PortalCalendar::Integration::iCal->new(ics_url => $ENV{CALENDAR_ICS_URL}, cache_dir => "$Bin/cache/lwp");
        try {
            @today_events = $calendar->get_today_events($dt);

            #p @today_events;
        } catch {
            warn "Error: $_";
        };
    }

    my $gray_probability = 0.25;
    my @icons;
    foreach my $name (List::Util::shuffle @PORTAL_ICONS) {
        push @icons,
            {
            name   => $name,
            grayed => (rand() < $gray_probability ? 1 : 0)
            };
    }
    while (scalar @icons < 16) {    # produce enough icons even with small number of source images
        push @icons, @icons;
    }

    return $self->render(
        template => 'calendar',
        format   => 'html',

        # other variables
        date                 => $dt,
        icons                => \@icons,
        calendar_events      => \@today_events,
        has_calendar_entries => (scalar @today_events ? 1 : 0),
    );
}

sub generate_bitmap {
    my $self      = shift;
    my $rotate    = shift;
    my $flip      = shift;
    my $threshold = shift;
    my $format    = shift;

    # This source image needs to be generated by 'server/scripts/generate_img_from_web' set up to run periodically from a cron job.
    my $img = Imager->new(file => "$Bin/generated_images/current_calendar.png") or die Imager->errstr;
    my $tmp;

    # If the generated image is larger (probably due to invalid CSS), crop it so that it display at least something:
    $tmp = $img->crop(left => 0, top => 0, width => $WIDTH, height => $HEIGHT);
    die $img->errstr unless $tmp;
    $img = $tmp;

    if ($rotate == 0) {
        $tmp = $img->copy();
    } elsif ($rotate == 1) {
        $tmp = $img->rotate(right => 90);
    } elsif ($rotate == 2) {
        $tmp = $img->rotate(right => 180);
    } elsif ($rotate == 3) {
        $tmp = $img->rotate(right => 270);
    } else {
        die "unknown 'rotate' value: $rotate";
    }
    die $img->errstr unless $tmp;
    $img = $tmp;

    if ($flip eq '') {
        $tmp = $img->copy();
    } elsif ($flip eq 'x') {
        $tmp = $img->flip(dir => 'h');
    } elsif ($flip eq 'y') {
        $tmp = $img->flip(dir => 'v');
    } elsif ($flip eq 'xy') {
        $tmp = $img->flip(dir => 'vh');
    } else {
        die "unknown 'flip' value: $flip";
    }
    die $img->errstr unless $tmp;
    $img = $tmp;

    # inplace conversion, no need to use $tmp here
    if (defined $threshold) {
        my @map = map { $_ >= $threshold ? 255 : 0 } 0 .. 255;
        $img->map(all => \@map);
    }

    if ($format eq 'png') {
        my $out;
        $img->write(data => \$out, type => 'png') or die;
        return $self->render(data => $out, format => 'png');
    } elsif ($format =~ /^raw/) {

        my $bitmap = '';
        if ($format eq 'raw8bpp') {
            foreach my $y (0 .. $img->getheight - 1) {
                foreach my $x (0 .. $img->getwidth - 1) {
                    my $color     = $img->getpixel(x => $x, y => $y);
                    my @rgb       = $color->rgba;
                    my $grayscale = $rgb[0];                            # 0 - 255
                    $bitmap .= chr($grayscale);
                }
            }
        } elsif ($format eq 'raw1bpp') {
            foreach my $y (0 .. $img->getheight - 1) {
                my $byte   = 0;
                my $bitcnt = 0;
                foreach my $x (0 .. $img->getwidth - 1) {
                    my $color     = $img->getpixel(x => $x, y => $y);
                    my @rgb       = $color->rgba;
                    my $grayscale = $rgb[0];

                    my $bit = ($grayscale > 0x80) ? 1 : 0;
                    $byte = $byte << 1 | $bit;
                    $bitcnt++;
                    if ($bitcnt == 8) {
                        $bitmap .= chr($byte);
                        $byte   = 0;
                        $bitcnt = 0;
                    }
                }
            }
        } else {
            die "Unknown format requested: " . $format;
        }

        # output format:
        #    "MM"
        #   checksum
        #    <sequence of raw values directly usable for uploading into eink display>

        my $out = "MM\n";
        $out .= sha1_hex($bitmap) . "\n";
        $out .= $bitmap;

        return $self->render(data => $out);
    } else {
        die "Unknown format requested: " . $format;
    }
}