#!/usr/bin/env perl

use strict;

use FindBin qw($Bin);
use lib "$Bin/../lib";

use Mojolicious::Lite;
use DDP;
use DateTime;
use DateTime::Format::Strptime;
use File::Slurp;
use Imager;
use Imager::Transform;

# Static files are automatically served from the /public subfolder.

get '/ping' => sub {
    my $self   = shift;
    my $result = {};
    return $self->render(json => { status => 'ok' });
};

get '/calendar/html' => sub {
    my $self = shift;
    return html_calendar($self, DateTime->now());
};

get '/calendar/html/:date' => sub {
    my $self = shift;
    my $dt   = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d')->parse_datetime($self->stash('date'));
    return html_calendar($self, $dt);
};

get '/calendar/png' => sub {
    my $self = shift;
    return $self->render_file(
        'filepath'            => "$Bin/generated_images/current_calendar.png",
        'format'              => 'png',
        'content_disposition' => 'inline',
    ) || $self->render(json => { status => "No calendar available" });
};

# /calendar/bitmap
# /calendar/bitmap?rotate=1&format=png
# /calendar/bitmap?rotate=2&flip=x
# /calendar/bitmap?rotate=3&flip=xy&format=rawgrayscale8
get '/calendar/bitmap' => sub {
    my $self = shift;

    my $rotate = $self->req->param('rotate') // 0;
    my $flip   = $self->req->param('flip')   // '';
    my $format = $self->req->param('format') // 'png';

    my $img = Imager->new(file => "$Bin/generated_images/current_calendar.png") or die Imager->errstr;
    my $tmp;

    if ($rotate == 0) {
        $tmp = $img->copy();
    } elsif ($rotate == 1) {
        $tmp = $img->rotate(right => 90);
    } elsif ($rotate == 2) {
        $tmp = $img->rotate(right => 180);
    } elsif ($rotate == 3) {
        $tmp = $img->rotate(right => 270);
    } else {
        die "unknown 'rotate' value: $rotate";
    }
    die $img->errstr unless $tmp;
    $img = $tmp;

    if ($flip eq '') {
        $tmp = $img->copy();
    } elsif ($flip eq 'x') {
        $tmp = $img->flip(dir => 'h');
    } elsif ($flip eq 'y') {
        $tmp = $img->flip(dir => 'v');
    } elsif ($flip eq 'xy') {
        $tmp = $img->flip(dir => 'vh');
    } else {
        die "unknown 'flip' value: $flip";
    }
    die $img->errstr unless $tmp;
    $img = $tmp;

    if ($format eq 'png') {
        my $out;
        $img->write(data => \$out, type => 'png') or die;
        return $self->render(data => $out, format => 'png');

    } elsif ($format eq 'rawgrayscale8') {

        # output format:
        #    "MM"
        #    <sequence of 1-byte grayscale values>
        my $out = 'MM';    # signature
        foreach my $y (0 .. $img->getheight - 1) {
            foreach my $x (0 .. $img->getwidth - 1) {
                my $color     = $img->getpixel(x => $x, y => $y);
                my @rgb       = $color->rgba;
                my $grayscale = $rgb[0];                            # 0 - 255
                $out .= chr($grayscale);
            }
        }
        return $self->render(data => $out);
    } else {
        die "Unknown format requested: " . $format;
    }
};

get '/' => sub {
    my $self = shift;
    return $self->render(template => 'test', format => 'html');
};

plugin 'TagHelpers';
plugin 'RenderFile';

app->secrets([ $ENV{MOJO_SECRET_PASSPHRASE} ]);
app->start;

########################################################################
sub html_calendar {
    my $self = shift;
    my $dt   = shift;

    $dt->set_locale('en-US');
    return $self->render(
        template => 'calendar',
        format   => 'html',

        # other variables
        date => $dt
    );

}